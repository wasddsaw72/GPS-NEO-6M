GPS module with LCD1602 and STM32 Nucleo f446.

Для проекта ипользовались следующие комопненты: 
1) STM32 Nucleof446
2) lcd 1602 на плате под arduino разьём (LCD Keypad Shield)
3) GPS Module NEO-6M

Схема подключения: 

![900px-DFR0009-PIN2](https://github.com/wasddsaw72/GPS-NEO-6M/assets/165021825/c2b818a2-768c-4b30-a737-484e0577de8f)

UART для передачи информации от GPS Module до STM32 Nucleo подключается к PC10(Tx) и PC11(Rx). 
Используется UART3 для передачи информации. 

Сам модуль можно запрограммировать на определённую скорость UART и т.д., но для моей задачи хавтило стандартных настроек.

Режим работы UART: 

Скорость - 9600 бит\сек.

Кол. стоп битов - 1 бит. 

Бит честности - нет. 

Режим Rx и Tx (хотя можно обойтись только Rx).

Сам GPS модуль работает по протоколу NMEA 0183 который передает информацию в виде 

$GNGGA,102030.000,5546.95900,N,03740.69200,E,1,08,2.0,142.0,M,0.0,M,,*

$GNGLL,5546.95900,N,03740.69200,E,102030.000,A,A*

$GNGSA,A,3,10,16,18,20,26,27,,,,,,,4.8,2.0,4.3,1*

$GNGSA,A,3,19,  ,  ,  ,  ,  ,,,,,,,4.8,2.0,4.3,4*

$GNGSA,A,3,82,  ,  ,  ,  ,  ,,,,,,,4.8,2.0,4.3,2*

$GPGSV,3,1,12,07,08,343,,08,07,304,,10,28,195,42,13,20,054,,0*

$GPGSV,3,2,12,15,27,087,,16,47,262,39,18,66,082,23,20,58,174,23,0*

$GPGSV,3,3,12,21,75,089,23,26,33,222,31,27,38,298,40,29,15,127,,0*

$BDGSV,1,1,01,19,29,174,28,0*

$GLGSV,3,1,09,74,08,001,34,66,55,096,,82,69,318,21,73,25,326,,0*

$GLGSV,3,2,09,80,20,258,,65,18,025,,83,21,292,,81,51,092,,0*

$GLGSV,3,3,09,67,26,161,,0*

$GNRMC,102030.000,A,5546.95900,N,03740.69200,E,0.12,49.75,200220,,,A,V*

$GNVTG,49.75,T,,M,0.12,N,0.22,K,A*

$GNZDA,102030.000,20,02,2020,00,00*

$GPTXT,01,01,01,ANTENNA OK*

$GNDHV,102030.000,0.03,0.000,0.000,0.000,0.00,,,,,M*

$GNGST,102030.000,6.9,,,,5.6,9.2,10.1*

$GPTXT,01,01,02,MS=7,7,061A8200,33,0,00000000,20,2,00028000*

Где из всего выше перечисленного нам для определения широты и долготы понадобиться строчка с индификатором "$GNGLL".

Для её нахождения и извленения информации используется сследущий цикл: 

        while(rx_buffer[i] != '\0')
         {

        	if((rx_buffer[i] == '$') && (rx_buffer[i+1] == 'G') && (rx_buffer[i+2] == 'P') && (rx_buffer[i+3] == 'G') && (rx_buffer[i+4] == 'L') && (rx_buffer[i+5] == 'L'))
        	   {

        		for( uint8_t i = 0; i <= 12 ; i++ )
        		{
        			latitude[i] = *(start + (i+7) );
        		}
        		latitude[13] = '\0';

        		for( uint8_t i = 0; i <= 14 ; i++)
        		{
        			longitude[i] = *(start + (i+20) );
        		}
        		longitude[15] = '\0';

        	  }

        	i++;
         }

Где "rx_buffer" - буфер в котором хранятся все данные в строковом формате которые отсылает GPS Module. 

Сам драйвер LCD и UART был освоен во воремя обучения на udemy, поэтому программа написанна без премения HAL.

